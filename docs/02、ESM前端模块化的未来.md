## 前端模块化历史进程

### 无模块标准化阶段：

- 文件划分
- 命名空间
- IIFE（立即执行函数）私有作用域

#### 文件划分

将应用的状态和逻辑分散到不同的文件中，然后通过`html`的`script`标签引入。存在的风险：

- 模块变量声明相当于全局声明和定义，会有**命名冲突**
- 变量都在全局定义，很难知道某个变量到底属于那些模块，带来调试困难

- 无法清晰管理模块之间的依赖关系和加载顺序，需要在`HTML`文件中手动调整顺序，不然可能产生运行错误

#### 命名空间

用于解决文件划分中的`全局变量定义`带来的一系列问题。每个变量都有自己的专属的命名空间，我们可以清楚地知道某个变量到底属于哪个`模块`，同时也避免全局变量命名的问题。

#### IIFE(立即执行函数)

IIFE 实现的模块化安全性要更高，对于模块作用域的区分更加彻底。

无论是命令空间还是 IIFE，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题，也就是在文件划分方式中所总结的问题 1 和问题 2，而并没有真正解决另外一个问题——模块加载。如果模块间存在依赖关系，那么 script 标签的加载顺序就需要收到严格的控制，一旦顺序不对，则很有可能产生运行时 Bug。

而随着前端工程的日益庞大，各个模块之间相互依赖已经是非常常见的事情，模块加载的需求已经成为了业界刚需，而以上的几种非标准模块化手段不能满足这个需求，因此我们需要指定一个行业标准去统一前端代码的模块化。

**只解决命名冲突问题，没解决模块加载之间依赖关系的问题**

### CommonJS

- 统一的模块化代码规范
- 实现自动加载模块的加载器(也称`loader`)

代码中使用 require 来导入一个模块，用 module.exports 来导出一个模块,实际上 Node.js 内部会有相应的 loader 转译模块代码，最后模块代码会被处理成下面这样:

```js
(function (exports, require, module, __filename, __dirname) {
  // 执行模块代码
  // 返回 exports 对象
});
```

问题：

- 模块加载器由 Node.js 提供，以来了 Node.js 本身功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。

-**CommonJS 本身约定以同步的方式进行模块加载**，服务端没问题，但是在浏览器端带来明显的性能问题。产生大量的同步模块请求，浏览器要等待响应返回后才能继续解析模块。**模块请求会造成浏览器 JS 解析过程的阻塞**，导致页面加载速度缓慢
